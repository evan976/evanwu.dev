export const title = 'Next 16: The Future of Next.js'
export const description = 'Next 16 is the latest version of Next.js, it is a major release that brings many new features and improvements.'
export const publishedAt = '2025-10-31'
export const image = '/articles/next-16.png'

## New Features and Improvements

### Cache Components

Cache Components are a new set of features designed to make caching in Next.js both more explicit, and more flexible. They center around the new `"use cache"` directive, which can be used to cache pages, components, and functions, and which leverages the compiler to automatically generate cache keys wherever it’s used.

Unlike the implicit caching found in previous versions of the App Router, caching with Cache Components is entirely opt-in. All dynamic code in any page, layout, or API route is executed at request time by default, giving Next.js an out-of-the-box experience that’s better aligned with what developers expect from a full-stack application framework.

Cache Components also complete the story of Partial Prerendering (PPR), which was first introduced in 2023. Prior to PPR, Next.js had to choose whether to render each URL statically or dynamically; there was no middle ground. PPR eliminated this dichotomy, and let developers opt portions of their static pages into dynamic rendering (via Suspense) without sacrificing the fast initial load of fully static pages.

You can enable Cache Components in your `next.config.ts` file:

```ts
/* [!code filename:next.config.ts] */
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  cacheComponents: true,
  // ...
}
 
export default nextConfig
```

### Next.js Devtools MCP

Next.js 16 introduces **Next.js DevTools MCP**, a Model Context Protocol integration for AI-assisted debugging with contextual insight into your application.

The Next.js DevTools MCP provides AI agents with:

- **Next.js knowledge**: Routing, caching, and rendering behavior
- **Unified logs**: Browser and server logs without switching contexts
- **Automatic error access**: Detailed stack traces without manual copying
- **Page awareness**: Contextual understanding of the active route

This enables AI agents to diagnose issues, explain behavior, and suggest fixes directly within your development workflow.

### `proxy.ts` (formerly `middleware.ts`)

`proxy.ts` replaces `middleware.ts` and makes the app’s network boundary explicit. `proxy.ts` runs on the Node.js runtime.

- **What to do**: Rename `middleware.ts` → `proxy.ts` and rename the exported function to `proxy`. Logic stays the same.
- **Why**: Clearer naming and a single, predictable runtime for request interception.

```ts
/* [!code filename:proxy.ts] */
import { NextRequest, NextResponse } from 'next/server'

export default function proxy(request: NextRequest) {
  // ...
  return NextResponse.redirect(new URL('/home', request.url))
}
```

### Logging Improvements

In Next.js 16 the development request logs are extended showing where time is spent.

- Compile: Routing and compilation
- Render: Running your code and React rendering

![Logging Improvements](/articles/next-16-development-log.png)

The build is also extended to show where time is spent. Each step in the build process is now shown with the time it took to complete.

```bash
▲ Next.js 16 (Turbopack)
 
 ✓ Compiled successfully in 615ms
 ✓ Finished TypeScript in 1114ms
 ✓ Collecting page data in 208ms
 ✓ Generating static pages in 239ms
 ✓ Finalizing page optimization in 5ms
```

<hr />

The following features were previously announced in the beta release:

## Developer Experience

### Turbopack (stable)

Turbopack has reached stability for both development and production builds, and is now the default bundler for all new Next.js projects. Since its beta release earlier this summer, adoption has scaled rapidly: more than 50% of development sessions and 20% of production builds on Next.js 15.3+ are already running on Turbopack.

With Turbopack, you can expect:

- 2–5× faster production builds
- Up to 10× faster Fast Refresh

We're making Turbopack the default to bring these performance gains to every Next.js developer, no configuration required. For apps with custom webpack setups, you can continue using webpack by running:

```bash
next dev --webpack
next build --webpack
```

### Turbopack File System Caching (beta)

Turbopack now supports filesystem caching in development, storing compiler artifacts on disk between runs for significantly faster compile times across restarts, especially in large projects.

Enable filesystem caching in your configuration:

```ts
/* [!code filename:next.config.ts] */
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    turbopackFileSystemCacheForDev: true,
  },
}

export default nextConfig
```

### Simplified create-next-app

`create-next-app` has been redesigned with a simplified setup flow, updated project structure, and improved defaults. The new template includes the App Router by default, TypeScript-first configuration, Tailwind CSS, and ESLint.

### Build Adapters API (alpha)

Following the [Build Adapters RFC](https://github.com/vercel/next.js/discussions/77740), we've worked with the community and deployment platforms to deliver the first alpha version of the Build Adapters API.

Build Adapters allow you to create custom adapters that hook into the build process, enabling deployment platforms and custom build integrations to modify Next.js configuration or process build output.

```ts
/* [!code filename:next.config.ts] */
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    adapterPath: require.resolve('./my-adapter.js'),
  },
}

export default nextConfig
```

### React Compiler Support (stable)

Built-in support for the React Compiler is now stable in Next.js 16 following the React Compiler's 1.0 release. The React Compiler automatically memoizes components, reducing unnecessary re-renders with zero manual code changes.

The `reactCompiler` configuration option has been promoted from `experimental` to stable. It is not enabled by default as we continue gathering build performance data across different application types. Expect compile times in development and during builds to be higher when enabling this option as the React Compiler relies on Babel.

```ts
/* [!code filename:next.config.ts] */
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  reactCompiler: true,
}

export default nextConfig
```

Install the latest version of the React Compiler plugin:

```bash
npm install babel-plugin-react-compiler@latest
```

## Core Features & Architecture

### Enhanced Routing and Navigation

Next.js 16 includes a complete overhaul of the routing and navigation system, making page transitions leaner and faster.

**Layout deduplication**: When prefetching multiple URLs with a shared layout, the layout is downloaded once instead of separately for each Link. For example, a page with 50 product links now downloads the shared layout once instead of 50 times, dramatically reducing the network transfer size.

**Incremental prefetching**: Next.js only prefetches parts not already in cache, rather than entire pages. The prefetch cache now:

- Cancels requests when the link leaves the viewport
- Prioritizes link prefetching on hover or when re-entering the viewport
- Re-prefetches links when their data is invalidated
- Works seamlessly with upcoming features like Cache Components

**Trade-off**: You may see more individual prefetch requests, but with much lower total transfer sizes. We believe this is the right trade-off for nearly all applications. If the increased request count causes issues, please let us know. We're working on additional optimizations to inline data chunks more efficiently.

These changes require no code modifications and are designed to improve performance across all apps.

### Improved Caching APIs

Next.js 16 introduces refined caching APIs for more explicit control over cache behavior.

### `revalidateTag()` (updated)

`revalidateTag()` now requires a `cacheLife` profile as the second argument to enable stale-while-revalidate (SWR) behavior:

```ts
import { revalidateTag } from 'next/cache'
 
// ✅ Use built-in cacheLife profile (we recommend 'max' for most cases)
revalidateTag('blog-posts', 'max')
 
// Or use other built-in profiles
revalidateTag('news-feed', 'hours')
revalidateTag('analytics', 'days')
 
// Or use an inline object with a custom revalidation time
revalidateTag('products', { revalidate: 3600 })
 
// ⚠️ Deprecated - single argument form
revalidateTag('blog-posts')
```

The profile argument accepts built-in `cacheLife` profile names (like `'max'`, `'hours'`, `'days'`) or custom profiles defined in your `next.config`. You can also pass an inline `{ expire: number }` object. We recommend using `'max'` for most cases, as it enables background revalidation for long-lived content. When users request tagged content, they receive cached data immediately while Next.js revalidates in the background.

Use `revalidateTag()` when you want to invalidate only properly tagged cached entries with stale-while-revalidate behavior. This is ideal for static content that can tolerate eventual consistency.

### `updateTag()` (new)

`updateTag()` is a new Server Actions-only API that provides **read-your-writes** semantics, expiring and immediately reading fresh data within the same request:

```ts
'use server'
 
import { updateTag } from 'next/cache'
 
export async function updateUserProfile(userId: string, profile: Profile) {
  await db.users.update(userId, profile)
 
  // Expire cache and refresh immediately - user sees their changes right away
  updateTag(`user-${userId}`)
}
```

This ensures interactive features reflect changes immediately. Perfect for forms, user settings, and any workflow where users expect to see their updates instantly.

### `refresh()` (new)

`refresh()` is a new Server Actions-only API for refreshing **uncached data only**. It doesn't touch the cache at all:

```ts
'use server'

import { refresh } from 'next/cache'
 
export async function markNotificationAsRead(notificationId: string) {
  // Update the notification in the database
  await db.notifications.markAsRead(notificationId)
 
  // Refresh the notification count displayed in the header
  // (which is fetched separately and not cached)
  refresh()
}
```

This API is complementary to the client-side `router.refresh()`. Use it when you need to refresh uncached data displayed elsewhere on the page after performing an action. Your cached page shells and static content remain fast while dynamic data like notification counts, live metrics, or status indicators refresh.

### React 19.2 and Canary Features

The App Router in Next.js 16 uses the latest React Canary release, which includes the newly released React 19.2 features and other features being incrementally stabilized. Highlights include:

- **View Transitions**: Animate elements that update inside a Transition or navigation
- **useEffectEvent**: Extract non-reactive logic from Effects into reusable Effect Event functions
- **Activity**: Render "background activity" by hiding UI with display: none while maintaining state and cleaning up Effects

Learn more in the [React 19.2 announcement](/articles/react-19-2).