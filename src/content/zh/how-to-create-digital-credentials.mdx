export const title = '用 Solana Attestation Service 打造数字凭证'
export const description = '手把手带你用 Solana Attestation Service（SAS）创建、签发、验证和撤销链上数字凭证。'
export const publishedAt = '2025-11-01'
export const image = '/solana-attestation.webp'

## 什么是 Solana Attestation Service？

Solana Attestation Service（简称 SAS）是一个强大的链上凭证系统，开发者可以在 Solana 上创建、管理、验证数字「证明」。你可以把它理解为去中心化版本的“发证与验真”能力：发放证书、徽章、出席证明，或者任何满足某种条件的数字凭证。

SAS 让你可以把链下数据和链上账户关联起来，构建可信的身份与资质系统，包括但不限于：

- **合规场景**：可验证的 KYC/AML 状态
- **职业资质**：职业证书、学历的链上验证
- **游戏成就**：里程碑/徽章发放
- **活动参与**：出席/打卡证明
- **会员忠诚度**：活跃度、贡献度等的奖励凭证

服务方（比如 DEX、DAO 或其他平台）可以读取这些凭证来做用户准入和功能分级，比如：让 VIP 会员访问专属内容、或只允许合格投资人参与某些链上机会。

本文将带你从零实现一个完整的凭证脚本，包含：

- 创建一个新的 Credential，并配置授权签名人
- 定义想要证明的数据 Schema
- 给指定用户签发 Attestation
- 更新授权签名人，增强安全性
- 验证某个用户是否持有有效凭证（正反两种情况）
- 关闭/撤销一条 Attestation（等同收回凭证）

最终你会看到一个能跑通的演示流程：

```bash
Starting Solana Attestation Service Demo
 
1. Setting up wallets and funding payer...
    - Airdrop completed: 384wkVUZsyuk53Npyy5N29tWTRA6dGe82b6fpBa4gKMDHoZYsb3iNAUfYMD6Lo2V3MYJeDhk8xvEDrmyxjeW2xdB
 
2. Creating Credential...
    - Credential created - Signature: 5LnkP762S9yvcLxFUVU7N3Mzen5Tqp8abC4h1rJYZn1vCviq7GpyFvUNVneVd8btiV7KK6pe5NEpXvwtTXK96gM1
    - Credential PDA: 3yB9Xrgg73oWxuQv8564q9LwwRL2rX2fjZD7ssy3X4M3
 
3.  Creating Schema...
    - Schema created - Signature: 4qHfY6FfjsUrssymRDWgShgr2sxRgWTbSdHxnJhgus7Cra5t6n6f4snhPDDkMyAX9bkqpD7aMCbKUpoJnD9NXzoS
    - Schema PDA: FfNqeLfPHy4p7FPgH2LDTm9gzVWSDcupA3LUhiMEzBXw
 
4. Creating Attestation...
    - Attestation created - Signature: 3czDWMmDkZEJbww7qfphcKe96vJJMAawFk2DedbknrzVpBSJ5fGBjtEK1aZHsYzvj8QLvRcadohEaxANNb4c4nUN
    - Attestation PDA: 6JEEL89jNXvxk63N6ND8njsp6e1Ve8BLZYShYNfjFajR
 
5. Updating Authorized Signers...
    - Authorized signers updated - Signature: 23V3bmTYnKUA6fT9WnchFmKi7bNj9biqxxnLBW9coUtkWhippu49PrY5fnefAcHWKofNDoojCicD2qJFq16RNz1Y
 
6. Verifying Attestations...
    - Attestation data: { name: 'test-user', age: 100, country: 'usa' }
    - Test User is verified
    - Random User is not verified
 
7. Closing Attestation...
    - Closed attestation - Signature: 5DS7GYpzKirWcusEgBhN3LGfX7D34q5rSQmbdNpCmzU5nYM1CUA4fJ3B9DRXwuiYNHvMnbBRSiMGDVJoCfLMc6ti
 
Solana Attestation Service demo completed successfully!
```

## 前置准备

开始前，确保你已经安装或了解：

- [Node.js](https://nodejs.org/en/download)（版本 22 及以上）
- [Solana CLI](https://solana.com/docs/intro/installation)（2.2.x 或更高）
- 对 [PDA](https://solana.com/docs/core/pda) 与[链上账户](https://solana.com/docs/core/accounts)有基本概念
- 有一定 [TypeScript](https://www.typescriptlang.org/) 经验

## 先理解一下 SAS

SAS 提供了一套标准的方法，让你可以在 Solana 上为某个主体（用户、组织，甚至其他程序）创建可验证的声明（Claim）。

### 核心概念

Attestation 系统的三件套：

- **Credential（凭证根）**：签发 Attestation 的主体（类似“大学” 或 “公司”）。
- **Schema（结构定义）**：规定可被证明的数据结构和字段（如姓名、年龄、技能等），相当于凭证模板。
- **Attestation（证明实例）**：针对某个主体、按照某个 Schema 发放的具体证明（就像某张毕业证/徽章）。

它们都以账户的形式存在链上，由 SAS Program 管理：[`22zoJMtdu4tQc2PzL74ZUT7FrwgB1Udec8DdW4yw4BdG`](https://explorer.solana.com/address/22zoJMtdu4tQc2PzL74ZUT7FrwgB1Udec8DdW4yw4BdG)（可在浏览器里查看）。

### 功能亮点

- **权限管理**：一个 Credential 可配置多个授权签名人来签发 Attestation。
- **有效期**：Attestation 支持设置过期时间。
- **结构化**：Schema 定义强类型结构，保证一致性。
- **版本化**：Schema 支持版本演进。
- **可暂停**：Schema 可暂停或禁用。
- **易验证**：任何人都能验证用户是否拥有某个 Credential 下的有效 Attestation。
- **可撤销**：授权签名人可以关闭（撤销）已签发的 Attestation。

### 使用注意

- **数据隐私**：Attestation 在链上，任何人可读。不要把敏感信息明文上链，必要时用哈希+链下存储。
- **信任来源**：任何人都能创建 Credential/Schema。作为“验方”，要确认你信任的签发方是谁。
- **用户校验**：确保连接的钱包是“真人用户”，可要求消息签名（如 [Sign in with Solana](https://github.com/phantom/sign-in-with-solana) 或配合 [Supabase](https://supabase.com/)）。
- **版本演进**：Schema 有版本，团队要有对应的监控与迭代流程。本文用单一版本做演示，高阶玩法以后再聊。
- **性能**：验证可以做批量与缓存。频繁校验的业务可以考虑做索引服务。

## 项目初始化

先准备一个演示项目：

```bash
mkdir solana-attestation-starter && cd solana-attestation-starter
```

初始化 Node 项目，并安装依赖：

```bash
pnpm init
pnpm i sas-lib gill
pnpm i -D typescript ts-node @types/node
```

创建 `tsconfig.json`：

```json
/* [!code filename:tsconfig.json] */
{
  "compilerOptions": {
    "target": "es2020",
    "module": "nodenext",
    "lib": ["es2020"],
    "declaration": true,
    "outDir": "./dist",
    "rootDir": "./",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "nodenext"
  },
  "rootDir": "./", 
  "outDir": "./dist",
  "include": ["./"],
  "exclude": ["node_modules", "dist"]
}
```

更新 `package.json` 的 scripts：

```json
/* [!code filename:package.json] */
{
  "scripts": {
    "start": "ts-node attestation.ts",
    "build": "tsc"
  }
}
```

## 开始实现

新建 `attestation.ts`，一步步补全：

### 引入与配置

先写必要的依赖和配置：

```ts
/* [!code filename:src/attestation.ts] */
import {
  getCreateCredentialInstruction,
  getCreateSchemaInstruction,
  serializeAttestationData,
  getCreateAttestationInstruction,
  fetchSchema,
  getChangeAuthorizedSignersInstruction,
  fetchAttestation,
  deserializeAttestationData,
  deriveAttestationPda,
  deriveCredentialPda,
  deriveSchemaPda,
  deriveEventAuthorityAddress,
  getCloseAttestationInstruction,
  SOLANA_ATTESTATION_SERVICE_PROGRAM_ADDRESS,
} from 'sas-lib'
import {
  airdropFactory,
  generateKeyPairSigner,
  lamports,
  Signature,
  TransactionSigner,
  Instruction,
  Address,
  Blockhash,
  createSolanaClient,
  createTransaction,
  SolanaClient,
} from 'gill'
import {
  estimateComputeUnitLimitFactory,
} from 'gill/programs'
 
const CONFIG = {
  CLUSTER_OR_RPC: 'devnet',
  CREDENTIAL_NAME: 'TEST-ORGANIZATION',
  SCHEMA_NAME: 'THE-BASICS',
  SCHEMA_LAYOUT: Buffer.from([12, 0, 12]),
  SCHEMA_FIELDS: ['name', 'age', 'country'],
  SCHEMA_VERSION: 1,
  SCHEMA_DESCRIPTION: 'Basic user information schema for testing',
  ATTESTATION_DATA: {
    name: 'Evan',
    age: 25,
    country: 'USA',
  },
  ATTESTATION_EXPIRY_DAYS: 365,
}
```

这段配置里包含：

- **连接信息**：这里使用 `devnet`
- **Credential 参数**：名称、授权签名人（后面会用）
- **Schema 定义**：结构、字段、描述
- **Attestation 数据**：要签发的实际信息

### 关于 Schema 与 Layout

继续之前，先看一下 Schema 的 Layout 与字段。`SCHEMA_LAYOUT` 用数字来表示每个字段的数据类型。以上例子里，`Buffer.from([12, 0, 12])` 对应三列：

- 第一个 `12` 表示字符串（name）
- `0` 表示 U8 整数（age）
- 最后一个 `12` 表示字符串（country）

`SCHEMA_FIELDS` 是对应的人类可读字段名。这样在创建 Attestation 时，数据能按 Schema 强类型校验。内置类型很多，从无符号/有符号整数（U8/U16/U32/U64/U128、I8-I128），到布尔、字符、字符串，甚至这些类型的向量，设计空间很灵活。完整列表参考官方文档。

### 通用工具函数

接着加两个工具函数，处理钱包生成/空投，以及打包发送交易：

```ts
async function setupWallets(client: SolanaClient) {
  try {
    const payer = await generateKeyPairSigner() // or loadKeypairSignerFromFile(path.join(process.env.PAYER))
    const authorizedSigner1 = await generateKeyPairSigner()
    const authorizedSigner2 = await generateKeyPairSigner()
    const issuer = await generateKeyPairSigner()
    const testUser = await generateKeyPairSigner()

    const airdrop = airdropFactory({ rpc: client.rpc, rpcSubscriptions: client.rpcSubscriptions })
    const airdropTx: Signature = await airdrop({
      commitment: 'processed',
      lamports: lamports(BigInt(1_000_000_000)),
      recipientAddress: payer.address
    })

    console.log(`    - Airdrop completed: ${airdropTx}`)
    return { payer, authorizedSigner1, authorizedSigner2, issuer, testUser }
  } catch (error) {
    throw new Error(`Failed to setup wallets: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}
```

`setupWallets` 会创建 5 个密钥对，并给 `payer` 账户空投 SOL：

- `payer`：支付交易费用
- `issuer`：创建 Credential 的主体
- `authorizedSigner1 / 2`：有权签发 Attestation 的签名人
- `testUser`：将被签发 Attestation 的用户

再加一个可复用的发送交易函数：

```ts
async function sendAndConfirmInstructions(
  client: SolanaClient,
  payer: TransactionSigner,
  instructions: Instruction[],
  description: string,
): Promise<Signature> {
  try {
    const simulationTx = createTransaction({
      version: 'legacy',
      feePayer: payer,
      instructions: instructions,
      latestBlockhash: {
        blockhash: '11111111111111111111111111111111' as Blockhash,
        lastValidBlockHeight: 0n,
      },
      computeUnitLimit: 1_400_000,
      computeUnitPrice: 1,
    })

    const estimateCompute = estimateComputeUnitLimitFactory({ rpc: client.rpc })
    const computeUnitLimit = await estimateCompute(simulationTx)
    const { value: latestBlockhash } = await client.rpc.getLatestBlockhash().send()
    const tx = createTransaction({
      version: 'legacy',
      feePayer: payer,
      instructions: instructions,
      latestBlockhash,
      computeUnitLimit,
      computeUnitPrice: 1, // In production, use dynamic pricing
    })

    const signature = await client.sendAndConfirmTransaction(tx)
    console.log(`    - ${description} - Signature: ${signature}`)
    return signature
  } catch (error) {
    throw new Error(`Failed to ${description.toLowerCase()}: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}
```

这个函数做两件事：

1. 先构造一笔“假交易”估算所需的计算单元（Compute Units）。
2. 再用估算结果组装真实交易并发送。

### 验证函数

接下来新增一个验证函数，检查某个用户是否持有有效 Attestation。需要传入用户地址（或关联地址）和要验证的 Schema 地址：

```ts
async function verifyAttestation({
  client,
  schemaPda,
  userAddress
}: {
  client: SolanaClient
  schemaPda: Address
  userAddress: Address
}): Promise<boolean> {
  try {
    const schema = await fetchSchema(client.rpc, schemaPda)
    if (schema.data.isPaused) {
      console.log(`    -  Schema is paused`)
      return false
    }
    const [attestationPda] = await deriveAttestationPda({
      credential: schema.data.credential,
      schema: schemaPda,
      nonce: userAddress,
    })
    const attestation = await fetchAttestation(client.rpc, attestationPda)
    const attestationData = deserializeAttestationData(schema.data, attestation.data.data as Uint8Array)
    console.log(`    - Attestation data:`, attestationData)
    const currentTimestamp = BigInt(Math.floor(Date.now() / 1000))
    return currentTimestamp < attestation.data.expiry
  } catch (error) {
    return false
  }
}
```

它会：

- 获取 Schema，确认 Schema 未暂停
- 为该用户推导 Attestation 的 PDA
- 反序列化数据，打印出被证明的内容
- 判断 Attestation 是否存在且未过期

另外，如果你已经知道 `credentialPda`，也可以作为二次校验，确认 Schema 关联的 Credential 正确。

### 第 1 步：初始化

现在写主流程函数，串起全部 7 个步骤：

```ts
async function main() {
  console.log('Starting Solana Attestation Service Demo\n')
  
  const client: SolanaClient = createSolanaClient({ urlOrMoniker: CONFIG.CLUSTER_OR_RPC })

  // Step 1: Setup wallets and fund payer
  console.log('1. Setting up wallets and funding payer...')
  const { payer, authorizedSigner1, authorizedSigner2, issuer, testUser } = await setupWallets(client)

  // Step 2: Create Credential


  // Step 3: Create Schema


  // Step 4: Create Attestation


  // Step 5: Update Authorized Signers


  // Step 6: Verify Attestations


  // Step 7. Close Attestation
}
 
main()
  .then(() => console.log('\nSolana Attestation Service demo completed successfully!'))
  .catch((error) => {
    console.error('❌ Demo failed:', error)
    process.exit(1)
  })
```

上面只是把流程骨架搭起来了。接下来把每一步补齐。

### 第 2 步：创建 Credential

先创建 Credential，相当于确立一个“发证机构”，并指定初始授权签名人。

在 `main` 里加上：

```ts
// Step 2: Create Credential
console.log('\n2. Creating Credential...')
const [credentialPda] = await deriveCredentialPda({
  authority: issuer.address,
  name: CONFIG.CREDENTIAL_NAME,
})

const createCredentialInstruction = getCreateCredentialInstruction({
  payer,
  credential: credentialPda,
  authority: issuer,
  name: CONFIG.CREDENTIAL_NAME,
  signers: [authorizedSigner1.address]
})

await sendAndConfirmInstructions(client, payer, [createCredentialInstruction], 'Credential created')
console.log(`    - Credential PDA: ${credentialPda}`)
```

这里主要用到 `sas-lib` 的两个工具：

- `deriveCredentialPda`：用 authority（issuer 地址）和 name 推导 Credential 的 PDA（同一个 issuer 不同 name 可以创建多个 Credential）。
- `getCreateCredentialInstruction`：生成创建 Credential 的指令。这里先只加一个授权签名人，稍后我们再演示怎么更新。

最后通过 `sendAndConfirmInstructions` 发送到链上。

### 第 3 步：创建 Schema

然后创建 Schema，定义可证明的数据结构（比如 name、age、country）：

```ts
// Step 3: Create Schema
console.log('\n3. Creating Schema...')
const [schemaPda] = await deriveSchemaPda({
  credential: credentialPda,
  name: CONFIG.SCHEMA_NAME,
  version: CONFIG.SCHEMA_VERSION,
})

const createSchemaInstruction = getCreateSchemaInstruction({
  authority: issuer,
  payer,
  name: CONFIG.SCHEMA_NAME,
  credential: credentialPda,
  description: CONFIG.SCHEMA_DESCRIPTION,
  fieldNames: CONFIG.SCHEMA_FIELDS,
  schema: schemaPda,
  layout: CONFIG.SCHEMA_LAYOUT,
})

await sendAndConfirmInstructions(client, payer, [createSchemaInstruction], 'Schema created')
console.log(`    - Schema PDA: ${schemaPda}`)
```

套路相同：推导 PDA、拼指令、发送交易。

- `deriveSchemaPda`：基于 Credential + name + version 推导 Schema PDA。
- `getCreateSchemaInstruction`：创建 Schema 的指令。

### 第 4 步：签发 Attestation

接着给特定用户签发一条 Attestation，包含具体数据与过期时间：

```ts
// Step 4: Create Attestation
console.log('\n4. Creating Attestation...')
const [attestationPda] = await deriveAttestationPda({
  credential: credentialPda,
  schema: schemaPda,
  nonce: testUser.address,
})

const schema = await fetchSchema(client.rpc, schemaPda)
const expiryTimestamp = Math.floor(Date.now() / 1000) + (CONFIG.ATTESTATION_EXPIRY_DAYS * 24 * 60 * 60)

const createAttestationInstruction = await getCreateAttestationInstruction({
  payer,
  authority: authorizedSigner1,
  credential: credentialPda,
  schema: schemaPda,
  attestation: attestationPda,
  nonce: testUser.address,
  expiry: expiryTimestamp,
  data: serializeAttestationData(schema.data, CONFIG.ATTESTATION_DATA),
})

await sendAndConfirmInstructions(client, payer, [createAttestationInstruction], 'Attestation created')
console.log(`    - Attestation PDA: ${attestationPda}`)
```

同样先用 `deriveAttestationPda` 推导 PDA。注意这里需要传 `nonce`，可以是用户地址，也可以是某个离线唯一标识的地址。

调用 `getCreateAttestationInstruction` 前，我们先：

- 用 `fetchSchema` 拉取链上的 Schema 数据，用于后续 `serializeAttestationData` 的序列化。
- 设定过期时间为一年后。

注意，这里 `authority` 使用的是 `authorizedSigner1`，也就是我们在第 2 步配置的授权签名人。

最后发送交易，创建 Attestation。

### 第 5 步：更新授权签名人

我们前面说过可以更新 Credential 的授权签名人。现在把 `authorizedSigner2` 加进去：

```ts
// Step 5: Update Authorized Signers
console.log('\n5. Updating Authorized Signers...')
const changeAuthSignersInstruction = await getChangeAuthorizedSignersInstruction({
  payer,
  authority: issuer,
  credential: credentialPda,
  signers: [authorizedSigner1.address, authorizedSigner2.address],
})

await sendAndConfirmInstructions(client, payer, [changeAuthSignersInstruction], 'Authorized signers updated')
```

把新的签名人数组传入即可（这是替换而不是追加，记得把想保留的旧签名人也一起传进去）。

### 第 6 步：验证 Attestation

跑一次验证，看看已签发用户与未签发用户的对比。实际业务里，这一步通常跑在后端登录流程里：

```ts
// Step 6: Verify Attestations
console.log('\n6. Verifying Attestations...')

const isUserVerified = await verifyAttestation({
  client,
  schemaPda,
  userAddress: testUser.address,
})
console.log(`    - Test User is ${isUserVerified ? 'verified' : 'not verified'}`)

const randomUser = await generateKeyPairSigner()
const isRandomVerified = await verifyAttestation({
  client,
  schemaPda,
  userAddress: randomUser.address,
})
console.log(`    - Random User is ${isRandomVerified ? 'verified' : 'not verified'}`)
```

这里我们分别用 `testUser` 和一个新建的 `randomUser` 调用两次 `verifyAttestation`：前者应该通过验证，后者应该失败。

### 第 7 步：关闭（撤销）Attestation

最后演示撤销一条 Attestation：

```ts
// Step 7. Close Attestation
console.log('\n7. Closing Attestation...')

const eventAuthority = await deriveEventAuthorityAddress()
const closeAttestationInstruction = await getCloseAttestationInstruction({
  payer,
  attestation: attestationPda,
  authority: authorizedSigner1,
  credential: credentialPda,
  eventAuthority,
  attestationProgram: SOLANA_ATTESTATION_SERVICE_PROGRAM_ADDRESS,
})
await sendAndConfirmInstructions(client, payer, [closeAttestationInstruction], 'Closed attestation')
```

撤销时需要拿到 Event Authority 地址（`deriveEventAuthorityAddress`），SAS 程序会用它来发出关闭事件。然后用 `getCloseAttestationInstruction` 生成指令，注意 `authority` 必须是授权签名人之一。

## 运行演示

在终端运行：

```bash
pnpm start
```

你会看到类似的输出：

```bash
Starting Solana Attestation Service Demo
 
1. Setting up wallets and funding payer...
    - Airdrop completed: 4QE4VGMxnvU9psgjDCYSoRsGEcdZzSsnqFKdzgTf5tPt2i833TC2gLdZE6QZfphie4S9MXNgJEVpQhvwgQJG5Bd5
 
2. Creating Credential...
    - Credential created - Signature: 2hb857yRrxficGU6zCMEvMwf6uKTASfgswgmwx1VS9z6zUL66FoapXMNK5VV7P3cZ6HktBMETp2Pu85EvSvUu1dr
    - Credential PDA: 14Bfygrnpj7bA5H8gvAU3Jr1dfpudZFr2QkJSUFUqoYp
 
3.  Creating Schema...
    - Schema created - Signature: 3Jo9pQgPcAJj1AmYm6weR9t4tw4Unq2qTxjS5przBUbwt94TLGm1sDaV7z5pBzt1Kyw4oxuCYg6NkUBijVs6vJ4X
    - Schema PDA: EyzsLnwtcCXrPJ8bSWHopRRNj3nGicXwuj8McfskToNs
 
4. Creating Attestation...
    - Attestation created - Signature: 2UJAcwTEF98xge1HPfZicYiBW4NqQDrtBiLcvAWWJ9sx9x4XyYZD4XGuwfkero11Mw5X9fhFzb7QTAMGvewDyZek
    - Attestation PDA: B2CQ5uqsHgV9QYcCdqfeZGEWNJijTTFgNutNVcFjae8D
 
5. Updating Authorized Signers...
    - Authorized signers updated - Signature: 3h7x8y8v5fGyV368b6DxDuJ6HpD73whAGVYNJLmTQPk3HezgZcWqsMXPcHqiYM9NQzwHJgCQmhyqnteE1yHVrDDu
 
6. Verifying Attestations...
    - Attestation data: { name: 'Evan', age: 25, country: 'USA' }
    - Test User is verified
    - Random User is not verified
 
7. Closing Attestation...
    - Closed attestation - Signature: 5DS7GYpzKirWcusEgBhN3LGfX7D34q5rSQmbdNpCmzU5nYM1CUA4fJ3B9DRXwuiYNHvMnbBRSiMGDVJoCfLMc6ti
 
Solana Attestation Service demo completed successfully!
```

## 总结

恭喜，至此你已经把一套完整的 SAS 流程跑通了。我们已经演示了：

- **创建 Credential**（发证主体）
- **定义 Schema**（结构化数据模板）
- **签发 Attestation** 给用户
- **管理授权签名人**（增减权限）
- **程序化验证** 某用户的有效凭证
- **关闭/撤销** 某条 Attestation

SAS 是在 Solana 上构建信任与身份系统的底座。不管你做的是合规、金融资质、职业认证，还是游戏成就，SAS 都能让你以去中心化、透明的方式发证与验真。

## 延伸阅读

- [Solana Attestation Service 文档](https://attest.solana.com/docs)
